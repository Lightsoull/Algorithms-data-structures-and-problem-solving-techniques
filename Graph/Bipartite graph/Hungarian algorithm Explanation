Sources
1-http://e-maxx.ru/algo/assignment_hungary
2-https://www.topcoder.com/community/data-science/data-science-tutorials/assignment-problem-and-hungarian-algorithm/
3-(code) https://github.com/ADJA/algos/blob/master/Graphs/HungarianMatching.cpp
-Problem
used to get the min cost of the max bipartite matching.
-Implementation Notes
1- it works on N*M matrix called cost martix (a) where N are people and M are jobs, where a[i][j] = the cost for the ith person 
to do the jth job, N is the left side and M is the right side.
2- it works for +ve and -ve weights.
3- if there is no edge between some person and a job put the cost with inf.
4- this implementation for MCBM (max cardinality bipartite matching with Min cost).
5- if you want to do it with max cost just multiply all the weights with -1.
-Complexity: O( N*N*M ) , where N <= M.

Examples
1- Given a bipartite graph, it is required to find in it a matching maximal matching of the minimum weight 
(that is, the matching size is maximized first, its cost is minimized).
To solve, we simply construct the assignment problem, putting the number "infinity" in place of the missing edges. 
After that, we solve the problem with the Hungarian algorithm, and remove from the answer
the edges of infinite weight (they could come in response if the problem has no solution in the form of a perfect matching).
2- Can be used to get the MPC (min path cover) also or any application on MCBM, but put costs with zero. 
3-The problem of potentials . Dana matrix a[1..n][1..m]. Required to find two arrays u[1..n] and v[1..m] such that 
for any i and j executed u[i] + v[j] <= a[i][j], but the sum of the elements of arrays u[] and v[] is maximum.
Knowing the Hungarian algorithm, the solution of this problem is not difficult: the Hungarian algorithm just finds the 
potential u[], v[] that satisfies the condition of the problem. On the other hand, without knowledge of the Hungarian algorithm, 
this problem seems almost impossible to solve.

CODE details
1- par[right]=left, is the match of the right side to the left side.
2- matrix a is the cost matrix.
3- u[] is the labeling for the left side and v[] is the labeling for the right side , that u[i]+v[j] = a[i][j].
4- link[right] stores the previous node in the right side that is matched before the current right side node.
5- the second do-while loop just alternate the augmenting path.

CODE
----
const int MAXN = 105;
const int INF = 1000 * 1000 * 1000;

int n,m;
int a[MAXN][MAXN];
int u[MAXN], v[MAXN], link[MAXN], par[MAXN], used[MAXN], minval[MAXN];

int main()
{

    scanf("%d %d", &n,&m);
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            scanf("%d", &a[i][j]);
    clr(par,0);
    clr(link,0);
    clr(u,0);
    clr(v,0);
    for (int i = 1; i <= n; i++)
    {
        for (int j = 0; j < MAXN; j++)
        {
            used[j] = false;
            minval[j] = INF;
        }
        int j_cur = 0;
        par[j_cur] = i;
        do
        {
            used[j_cur] = true;
            int j_next, delta = INF, i_cur = par[j_cur];
            for (int j = 0; j <= m; j++)
                if (!used[j])
                {
                    int cur = a[i_cur][j] - u[i_cur] - v[j];
                    if (cur < minval[j])
                    {
                        minval[j] = cur; link[j] = j_cur;
                    }
                    if (minval[j] < delta)
                    {
                        delta = minval[j]; j_next = j;
                    }
                }
            for (int j = 0; j <= m; j++)
                if (used[j])
                {
                    u[par[j]] += delta; v[j] -= delta;
                }
                else
                {
                    minval[j] -= delta;
                }
            j_cur = j_next;
        }while (par[j_cur]);
       
        do
        {
            int j_prev = link[j_cur];
            par[j_cur] = par[j_prev];
            j_cur = j_prev;
        } while (j_cur > 0);
    }
    int res=-v[0];
    printf("%d", res);
    vector< pair<int,int> > matchings;
    for(int i=1;i<=m;i++)
        if(par[i]!=0)
         matchings.pb(mp(par[i],i));
}
----------------------------------------------------------------------------------------------------------------------------------------
