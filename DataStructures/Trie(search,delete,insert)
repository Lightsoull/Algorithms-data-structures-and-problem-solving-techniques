Note
If you are inserting binary number in a trie takecare that binary numbers differ in the number of bits so let a certain fixed number
of bits for example 30 so if the number of bits less than that number you will continue the remaining with zeros.
----------------------------------------------------------------------------------------------------------------------------------------
Using map for child
struct trie
{
    map< char,trie* > child;
    int isleaf;
    trie()
    {
        child=map<char,trie*> ();
        isleaf=0;
    }
};
Using array for child
struct trie
{
    trie* child[3];
    int isleaf;
    trie()
    {
        isleaf=0;
        clr(child,0);
    }
};
----------------------------------------------------------------------------------------------------------------------------------------
  Using map for child
  void insertt(trie* cur,string word,int id)
    {
        if(id==sz(word))
        {
            cur->isleaf++;
            return ;
        }
       char ch=word[id];
      if(cur->child.find(ch)==cur->child.end())
       {
           cur->child[ch]= new trie();
       }
         trie* node=cur->child[ch];
    insertt(node,word,id+1);
    }
  Using array for child
  void insertt(trie* cur,int id,string s)
  {
    if(id==sz(s))
    {
        cur->isleaf++;
        return;
    }
    int ch=s[id]-'0';
    if(cur->child[ch]==0)
    {
        cur->child[ch]=new trie();
    }
   
    insertt(cur->child[ch],id+1,s);
  }
  -------------------------------------------------------------------------------------------------------------------------------------
  Using map for child  
  bool searchh(trie* cur,string word,int id)
    {
        if(id==sz(word))
            return  cur->isleaf!=0 ;
        char ch=word[id];
      if(cur->child.find(ch)==cur->child.end())
       {
           return 0;
       }
         trie* node=cur->child[ch];
        return  searchh(node,word,id+1);
    }
  Using array for child  
  bool searchh(trie* cur,string word,int id)
    {
        if(id==sz(word))
            return  cur->isleaf!=0 ;
        char ch=word[id];
      if(cur->child[ch]==0)
       {
           return 0;
       }
         trie* node=cur->child[ch];
        return  searchh(node,word,id+1);
    }
  --------------------------------------------------------------------------------------------------------------------------------------
    /*
    to delete there is 2 ways the first way i have to make sure that the cur node have no children and leaf==0
    the second way is to make a vaiable integer cnt in the trie struct and when i insert a word i increase the node
    cnt once i visit it and at delete i decrease the cnt once i visit it and when the count become zero i erase
    it.
    */
 First way 
    bool del(trie* cur,string word,int id)
    {
        if(id==sz(word))
        {
            if(cur->isleaf==0)
                return 0;
            cur->isleaf--;
            return sz(cur->child)==0&&cur->isleaf==0;
        }
        char ch=word[id];
      if(cur->child.find(ch)==cur->child.end())
       {
           return 0;
       }
         trie* node=cur->child[ch];
        bool ret=  del(node,word,id+1);
        if(ret)
        {
            cur->child.erase(cur->child.find(ch));
            return sz(cur->child)==0&&cur->isleaf==0;
        }
        return 0;
    }
  Second way but i use the isleaf itself as a cnt and i am using array child not map
  void removee(trie* cur,int id,string s)
  {
    if(id==sz(s))
    {

        return ;
    }

    int ch=s[id]-'0';

    removee(cur->child[ch],id+1,s);
    cur->child[ch]->isleaf--;
    if(cur->child[ch]->isleaf==0)
    {
        cur->child[ch]=0;

    }

  }
----------------------------------------------------------------------------------------------------------------------------------------
    int main()
    {
            trie* root=new trie();
            insertt(root,bin,0);
            del(root,bin,0);
    }
